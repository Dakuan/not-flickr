'use strict';

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj['default'] : obj; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

/**
 * Store
 *
 * Stores hold application state. They respond to actions sent by the dispatcher
 * and broadcast change events to listeners, so they can grab the latest data.
 * The key thing to remember is that the only way stores receive information
 * from the outside world is via the dispatcher.
 */

var _EventEmitter2 = require('eventemitter3');

var EventEmitter = _interopRequire(_EventEmitter2);

var _assign = require('object-assign');

var assign = _interopRequire(_assign);

var Store = (function (_EventEmitter) {

  /**
   * Stores are initialized with a reference
   * @type {Object}
   */

  function Store() {
    _classCallCheck(this, Store);

    _EventEmitter.call(this);

    this.state = null;

    // Map of action ids to collection of action handlers
    // Async handlers are categorized as 'begin', 'success', or 'error'
    // Non-async handlers are categorized as 'success'
    this._handlers = {};

    // Like above, except generic handlers are called for every action
    this._genericHandlers = {
      begin: [],
      success: [],
      failure: []
    };

    // Array of { matcher, handler }
    // matcher is called with each payload
    // handler is called if matcher returns true
    this._matchHandlers = [];
  }

  _inherits(Store, _EventEmitter);

  Store.prototype.setState = function setState(newState) {
    // Do a transactional state update if a function is passed
    if (typeof newState === 'function') {
      var prevState = this._isHandlingDispatch ? this._pendingState : this.state;

      newState = newState(prevState);
    }

    if (this._isHandlingDispatch) {
      this._pendingState = this._assignState(this._pendingState, newState);
      this._emitChangeAfterHandlingDispatch = true;
    } else {
      this.state = this._assignState(this.state, newState);
      this.emit('change');
    }
  };

  Store.prototype.replaceState = function replaceState(newState) {
    if (this._isHandlingDispatch) {
      this._pendingState = this._assignState(undefined, newState);
      this._emitChangeAfterHandlingDispatch = true;
    } else {
      this.state = this._assignState(undefined, newState);
      this.emit('change');
    }
  };

  Store.prototype.getStateAsObject = function getStateAsObject() {
    return this.state;
  };

  Store.assignState = function assignState(oldState, newState) {
    return assign({}, oldState, newState);
  };

  Store.prototype._assignState = function _assignState() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (this.constructor.assignState || Store.assignState).apply(undefined, args);
  };

  Store.prototype.forceUpdate = function forceUpdate() {
    if (this._isHandlingDispatch) {
      this._emitChangeAfterHandlingDispatch = true;
    } else {
      this.emit('change');
    }
  };

  Store.prototype.register = function register(actionId, handler) {
    actionId = ensureActionId(actionId);

    if (typeof handler !== 'function') {
      return;
    }var actionHandlers = this._handlers[actionId] || {};
    var actionSuccessHandlers = actionHandlers.success || [];

    actionSuccessHandlers.push(handler.bind(this));

    actionHandlers.success = actionSuccessHandlers;
    this._handlers[actionId] = actionHandlers;
  };

  Store.prototype.registerAsync = function registerAsync(actionId, beginHandler, successHandler, failureHandler) {
    actionId = ensureActionId(actionId);

    var actionHandlers = this._handlers[actionId] || {};

    var newActionHandlers = {
      begin: beginHandler,
      success: successHandler,
      failure: failureHandler
    };

    for (var handlerType in newActionHandlers) {
      var handler = newActionHandlers[handlerType];

      if (typeof handler !== 'function') continue;

      var actionTypeHandlers = actionHandlers[handlerType] || [];

      actionTypeHandlers.push(handler.bind(this));

      actionHandlers[handlerType] = actionTypeHandlers;
    }

    this._handlers[actionId] = actionHandlers;
  };

  Store.prototype.registerAll = function registerAll(handler) {
    if (typeof handler !== 'function') {
      return;
    }this._genericHandlers.success.push(handler.bind(this));
  };

  Store.prototype.registerAllAsync = function registerAllAsync(beginHandler, successHandler, failureHandler) {
    var newActionHandlers = {
      begin: beginHandler,
      success: successHandler,
      failure: failureHandler
    };

    for (var handlerType in newActionHandlers) {
      var handler = newActionHandlers[handlerType];

      if (typeof handler !== 'function') continue;

      this._genericHandlers[handlerType].push(handler.bind(this));
    }
  };

  Store.prototype.registerMatch = function registerMatch(matcher, handler) {
    this._matchHandlers.push({
      matcher: matcher,
      handler: handler.bind(this)
    });
  };

  Store.prototype.waitFor = function waitFor(tokensOrStores) {
    this._waitFor(tokensOrStores);
  };

  Store.prototype.handler = function handler(payload) {
    var body = payload.body;
    var actionId = payload.actionId;
    var asyncType = payload.async;
    var actionArgs = payload.actionArgs;
    var error = payload.error;

    // Collect array of all matching action handlers
    var actionHandlers = this._handlers[actionId] || {};
    var genericHandlers = this._genericHandlers;
    var matchHandlers = this._matchHandlers;

    var matchedActionHandlers = [];

    if (asyncType === 'begin' || asyncType === 'failure') {
      var matchedAsyncActionHandlers = actionHandlers[asyncType];
      var matchedAsyncGenericHandlers = genericHandlers[asyncType];

      if (matchedAsyncActionHandlers) {
        matchedActionHandlers = matchedActionHandlers.concat(matchedAsyncActionHandlers);
      }

      if (matchedAsyncGenericHandlers) {
        matchedActionHandlers = matchedActionHandlers.concat(matchedAsyncGenericHandlers);
      }
    } else {
      var matchedSuccessActionHandlers = actionHandlers.success;
      var matchedSuccessGenericHandlers = genericHandlers.success;

      if (matchedSuccessActionHandlers) {
        matchedActionHandlers = matchedActionHandlers.concat(matchedSuccessActionHandlers);
      }

      if (matchedSuccessGenericHandlers) {
        matchedActionHandlers = matchedActionHandlers.concat(matchedSuccessGenericHandlers);
      }
    }

    // Collect handlers that match custom matcher functions
    // These are collected separately because they always receive the payload
    // as the sole argument.
    var customMatchedActionHandlers = [];

    for (var _iterator = matchHandlers, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i2 >= _iterator.length) break;
        _ref = _iterator[_i2++];
      } else {
        _i2 = _iterator.next();
        if (_i2.done) break;
        _ref = _i2.value;
      }

      var matcher = _ref.matcher;
      var handler = _ref.handler;

      if (matcher(payload)) {
        customMatchedActionHandlers.push(handler);
      }
    }

    // Determine args to pass to handlers based on action type
    var args = undefined;

    switch (asyncType) {
      case 'begin':
        args = [payload];
        break;
      case 'failure':
        args = [error, payload];
        break;
      default:
        args = [body, payload];
    }

    this._isHandlingDispatch = true;
    this._pendingState = this._assignState(undefined, this.state);
    this._emitChangeAfterHandlingDispatch = false;

    try {
      // Dispatch matched handlers
      for (var _iterator2 = matchedActionHandlers, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i3 >= _iterator2.length) break;
          _ref2 = _iterator2[_i3++];
        } else {
          _i3 = _iterator2.next();
          if (_i3.done) break;
          _ref2 = _i3.value;
        }

        var actionHandler = _ref2;

        actionHandler.apply(undefined, args);
      }

      // Dispatch custom matched handers
      for (var _i = 0; _i < customMatchedActionHandlers.length; _i++) {
        var actionHandler = customMatchedActionHandlers[_i];
        actionHandler(payload);
      }
    } finally {
      var emit = false;

      if (this._emitChangeAfterHandlingDispatch) {
        emit = true;
        this.state = this._pendingState;
      }

      this._isHandlingDispatch = false;
      this._pendingState = undefined;
      this._emitChangeAfterHandlingDispatch = false;

      if (emit) this.emit('change');
    }
  };

  return Store;
})(EventEmitter);

module.exports = Store;

function ensureActionId(actionOrActionId) {
  return typeof actionOrActionId === 'function' ? actionOrActionId._id : actionOrActionId;
}